---
AWSTemplateFormatVersion: "2010-09-09"

Description: "Creates all the components needed for hosting UE5 Pixel Streaming on AWS"
Parameters:
  VPCName:
    Description: The name of the VPC being created.
    Type: String
    Default: "unreal-vpc"
  VPCCIDR:
    Description: The CIDR of the VPC being created.
    Type: String
    Default: "10.0.0.0/16"
  Public0CIDR:
    Description: The CIDR of the first public subnet being created.
    Type: String
    Default: "10.0.0.0/24"
  Public1CIDR:
    Description: The CIDR of the second public subnet being created.
    Type: String
    Default: "10.0.1.0/24"
  BackendURL:
    Description: The URL of the backend server
    Type: String
    Default: "https://backend.weihong.tech/unreal"
  MatchmakerAMI:
    Description: The AMI for Matchmaker server
    Type: String
    Default: "ami-0e86d843c7edaf4e8"
  MatchmakerInstanceType:
    Description: The instance type for Matchmaker server
    Type: String
    Default: "t2.micro"
  SignallingServerAMI:
    Description: The AMI for Signalling server
    Type: String
    Default: "ami-0a9fbe194f554911f"
  SignallingInstanceType:
    Description: The instance type for Signalling server
    Type: String
    Default: "g4dn.xlarge"

Mappings:
  AZRegions:
    ap-southeast-1:
      AZs: ["a", "b"]

Resources:
  VPC:
    Type: "AWS::EC2::VPC"
    Properties:
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      CidrBlock: !Ref "VPCCIDR"
      Tags:
        - Key: "Application"
          Value:
            Ref: "AWS::StackName"
        - Key: "Network"
          Value: "Public"
        - Key: "Name"
          Value: !Ref "VPCName"

  PublicSubnet0:
    Type: "AWS::EC2::Subnet"
    Properties:
      VpcId:
        Ref: "VPC"
      AvailabilityZone:
        Fn::Sub:
          - "${AWS::Region}${AZ}"
          - AZ: !Select [0, !FindInMap ["AZRegions", !Ref "AWS::Region", "AZs"]]
      CidrBlock: !Ref "Public0CIDR"
      MapPublicIpOnLaunch: "true"
      Tags:
        - Key: "Application"
          Value:
            Ref: "AWS::StackName"
        - Key: "Network"
          Value: "Public"
        - Key: "Name"
          Value: !Join
            - ""
            - - !Ref "VPCName"
              - "-public-"
              - !Select [0, !FindInMap ["AZRegions", !Ref "AWS::Region", "AZs"]]

  PublicSubnet1:
    Type: "AWS::EC2::Subnet"
    Properties:
      VpcId:
        Ref: "VPC"
      AvailabilityZone:
        Fn::Sub:
          - "${AWS::Region}${AZ}"
          - AZ: !Select [1, !FindInMap ["AZRegions", !Ref "AWS::Region", "AZs"]]
      CidrBlock: !Ref "Public1CIDR"
      MapPublicIpOnLaunch: "true"
      Tags:
        - Key: "Application"
          Value:
            Ref: "AWS::StackName"
        - Key: "Network"
          Value: "Public"
        - Key: "Name"
          Value: !Join
            - ""
            - - !Ref "VPCName"
              - "-public-"
              - !Select [1, !FindInMap ["AZRegions", !Ref "AWS::Region", "AZs"]]

  InternetGateway:
    Type: "AWS::EC2::InternetGateway"
    Properties:
      Tags:
        - Key: "Application"
          Value:
            Ref: "AWS::StackName"
        - Key: "Network"
          Value: "Public"
        - Key: "Name"
          Value: !Join
            - ""
            - - !Ref "VPCName"
              - "-IGW"

  GatewayToInternet:
    Type: "AWS::EC2::VPCGatewayAttachment"
    Properties:
      VpcId:
        Ref: "VPC"
      InternetGatewayId:
        Ref: "InternetGateway"

  PublicRouteTable:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId:
        Ref: "VPC"
      Tags:
        - Key: "Application"
          Value:
            Ref: "AWS::StackName"
        - Key: "Network"
          Value: "Public"
        - Key: "Name"
          Value: !Join
            - ""
            - - !Ref "VPCName"
              - "-public-route-table"

  PublicRoute:
    Type: "AWS::EC2::Route"
    DependsOn: "GatewayToInternet"
    Properties:
      RouteTableId:
        Ref: "PublicRouteTable"
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId:
        Ref: "InternetGateway"

  PublicSubnet0RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: "PublicSubnet0"
      RouteTableId:
        Ref: "PublicRouteTable"

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: "PublicSubnet1"
      RouteTableId:
        Ref: "PublicRouteTable"

  SignallingALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for signalling ALB"
      GroupName: "SignallingALBSecurityGroup"
      SecurityGroupIngress:
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 443
          ToPort: 443
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 80
          ToPort: 80
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 22
          ToPort: 22
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 19303
          ToPort: 19303
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "UDP"
          FromPort: 19303
          ToPort: 19303
      VpcId:
        Ref: "VPC"

  SignallingInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for signalling instance"
      GroupName: "SignallingInstanceSecurityGroup"
      SecurityGroupIngress:
        - SourceSecurityGroupId:
            Ref: "SignallingALBSecurityGroup"
          IpProtocol: "TCP"
          FromPort: 443
          ToPort: 443
        - SourceSecurityGroupId:
            Ref: "SignallingALBSecurityGroup"
          IpProtocol: "TCP"
          FromPort: 80
          ToPort: 80
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 19303
          ToPort: 19303
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "UDP"
          FromPort: 19303
          ToPort: 19303
      VpcId:
        Ref: "VPC"

  SignallingServerALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: "SignallingServerALB"
      Scheme: "internet-facing"
      SecurityGroups:
        - Ref: "SignallingALBSecurityGroup"
      Subnets:
        - Ref: "PublicSubnet0"
        - Ref: "PublicSubnet1"
      Type: "application"

  SignallingTG:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: "SignallingTargetGroup01"
      Port: 80
      Protocol: "HTTP"
      VpcId:
        Ref: "VPC"

  SignallingTG2:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: "SignallingTargetGroup02"
      Port: 80
      Protocol: "HTTP"
      VpcId:
        Ref: "VPC"

  SignallingT3:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: "SignallingTargetGroup03"
      Port: 80
      Protocol: "HTTP"
      VpcId:
        Ref: "VPC"

  SignallingTG4:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: "SignallingTargetGroup04"
      Port: 80
      Protocol: "HTTP"
      VpcId:
        Ref: "VPC"

  SignallingALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn:
            Ref: "SignallingTG"
          Type: "forward"
      LoadBalancerArn:
        Ref: "SignallingServerALB"
      Port: 80
      Protocol: "HTTP"

  SignallingALBListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn:
            Ref: "SignallingTG2"
          Type: "forward"
      Conditions:
        - Field: "query-string"
          QueryStringConfig:
            Values:
              - Key: "session"
                Value: "02"
      ListenerArn:
        Ref: "SignallingALBListener"
      Priority: 1

  SignallingALBListenerRule03:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn:
            Ref: "SignallingT3"
          Type: "forward"
      Conditions:
        - Field: "query-string"
          QueryStringConfig:
            Values:
              - Key: "session"
                Value: "03"
      ListenerArn:
        Ref: "SignallingALBListener"
      Priority: 2

  SignallingALBListenerRule04:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn:
            Ref: "SignallingTG4"
          Type: "forward"
      Conditions:
        - Field: "query-string"
          QueryStringConfig:
            Values:
              - Key: "session"
                Value: "04"
      ListenerArn:
        Ref: "SignallingALBListener"
      Priority: 3

  MatchmakerALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for matchmaker ALB"
      GroupName: "MatchmakerALBSecurityGroup"
      SecurityGroupIngress:
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 443
          ToPort: 443
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 90
          ToPort: 90
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "TCP"
          FromPort: 22
          ToPort: 22
      VpcId:
        Ref: "VPC"

  MatchmakerInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for matchmaker instance"
      GroupName: "MatchmakerInstanceSecurityGroup"
      SecurityGroupIngress:
        - SourceSecurityGroupId:
            Ref: "MatchmakerALBSecurityGroup"
          IpProtocol: "TCP"
          FromPort: 443
          ToPort: 443
        - SourceSecurityGroupId:
            Ref: "MatchmakerALBSecurityGroup"
          IpProtocol: "TCP"
          FromPort: 90
          ToPort: 90
        - SourceSecurityGroupId:
            Ref: "SignallingInstanceSecurityGroup"
          IpProtocol: "TCP"
          FromPort: 9999
          ToPort: 9999
      VpcId:
        Ref: "VPC"

  MatchMakerServerALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: "MatchMakerPublicALB"
      Scheme: "internet-facing"
      SecurityGroups:
        - Ref: "MatchmakerALBSecurityGroup"
      Subnets:
        - Ref: "PublicSubnet0"
        - Ref: "PublicSubnet1"
      Type: "application"

  MatchMakerTG:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn:
      - MatchMakingInstance
    Properties:
      Name: "MatchMakerTargetGroup"
      Port: 90
      Protocol: "HTTP"
      TargetType: "instance"
      Targets:
        - Id: !Ref "MatchMakingInstance"
      VpcId:
        Ref: "VPC"

  MatchMakerALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn:
            Ref: "MatchMakerTG"
          Type: "forward"
      LoadBalancerArn:
        Ref: "MatchMakerServerALB"
      Port: 90
      Protocol: "HTTP"

  MatchmakerLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn:
      - ConnectionHandlerAPI
    Properties:
      LaunchTemplateData:
        ImageId: !Ref "MatchmakerAMI"
        TagSpecifications:
          - ResourceType: "instance"
            Tags:
              - Key: "Name"
                Value: "Matchmaker"
              - Key: "type"
                Value: "matchmaker"
        InstanceType: !Ref "MatchmakerInstanceType"
        SecurityGroupIds:
          - !GetAtt MatchmakerInstanceSecurityGroup.GroupId
        UserData:
          Fn::Base64: !Sub
            - |
              #!/bin/bash
              su ubuntu
              git clone -b UE5.3.3 https://github.com/S35-Capstone-2023/PixelStreamingInfrastructure.git
              cd ./PixelStreamingInfrastructure/Matchmaker
              ./platform_scripts/bash/run.sh --WebSocketURL ${WebSocketURL}
            - WebSocketURL: !Sub "wss://${ConnectionHandlerAPI}.execute-api.${AWS::Region}.amazonaws.com/production"
      LaunchTemplateName: "MatchmakerLaunchTemplate"

  SignallingLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn:
      - Ec2InstanceProfiles
    Properties:
      LaunchTemplateData:
        InstanceType: !Ref "SignallingInstanceType"
        IamInstanceProfile:
          Arn: !GetAtt
            - Ec2InstanceProfiles
            - Arn
        TagSpecifications:
          - ResourceType: "instance"
            Tags:
              - Key: "Name"
                Value: "Signalling"
              - Key: "type"
                Value: "signalling"
        SecurityGroupIds:
          - !GetAtt SignallingInstanceSecurityGroup.GroupId
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            su ubuntu
            git clone -b UE5.3.3 https://github.com/S35-Capstone-2023/PixelStreamingInfrastructure.git
      LaunchTemplateName: "SignallingLaunchTemplate"

  MatchMakingInstance:
    Type: AWS::EC2::Instance
    DependsOn:
      - Ec2InstanceProfiles
      - MatchmakerLaunchTemplate
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref "MatchmakerLaunchTemplate"
        Version: "1"
      SubnetId: !Ref "PublicSubnet0"
      IamInstanceProfile: !Ref "Ec2InstanceProfiles"

  Ec2InstanceProfiles:
    Type: AWS::IAM::InstanceProfile
    DependsOn:
      - EC2IAMRole
    Properties:
      InstanceProfileName: "instanceProfileForUE"
      Roles:
        - !Ref "EC2IAMRole"

  EC2IAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Description: "Role for EC2 servers"
      Policies:
        - PolicyName: registerInstancesToTG
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "elasticloadbalancing:RegisterTargets"
                Resource: !Sub "arn:aws:elasticloadbalancing:*:${AWS::AccountId}:targetgroup/*/*"
        - PolicyName: accessWebsocket
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "execute-api:Invoke"
                Resource: !Sub "arn:aws:execute-api:*:${AWS::AccountId}:*"
        - PolicyName: accessS3Storage
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:*"
                  - "s3-object-lambda:*"
                Resource:
                  - !Sub "arn:aws:execute-api:*:${AWS::AccountId}:*"
      RoleName: "EC2Role"

  LambdaIAMRole:
    Type: AWS::IAM::Role
    DependsOn:
      - EC2IAMRole
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Description: "Role for lambda functions"
      Policies:
        - PolicyName: VPCAccessExecutionPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AWSLambdaVPCAccessExecutionPermissions
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "ec2:CreateNetworkInterface"
                  - "ec2:DescribeNetworkInterfaces"
                  - "ec2:DescribeSubnets"
                  - "ec2:DeleteNetworkInterface"
                  - "ec2:AssignPrivateIpAddresses"
                  - "ec2:UnassignPrivateIpAddresses"
                Resource: "*"
        - PolicyName: invokeLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunctionUrl"
                  - "lambda:InvokeFunction"
                  - "lambda:GetFunction"
                  - "lambda:InvokeAsync"
                Resource: !Sub "arn:aws:lambda:*:${AWS::AccountId}:function:*"
        - PolicyName: terminateEC2Intance
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "ec2:TerminateInstances"
                Resource: !Sub "arn:aws:ec2:*:${AWS::AccountId}:instance/*"
        - PolicyName: registerInstancesToTG
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "elasticloadbalancing:RegisterTargets"
                Resource: !Sub "arn:aws:elasticloadbalancing:*:${AWS::AccountId}:targetgroup/*/*"
        - PolicyName: describeLoadbalancer
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "elasticloadbalancing:DescribeLoadBalancerAttributes"
                  - "elasticloadbalancing:DescribeLoadBalancers"
                  - "elasticloadbalancing:DescribeListeners"
                  - "elasticloadbalancing:DescribeTargetGroups"
                  - "elasticloadbalancing:DescribeRules"
                Resource: "*"
        - PolicyName: root
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: VisualEditor0
                Effect: Allow
                Action:
                  - "iam:PassRole"
                Resource: !GetAtt EC2IAMRole.Arn
              - Sid: VisualEditor1
                Effect: Allow
                Action:
                  - "ec2:DescribeInstances"
                  - "cloudwatch:PutMetricData"
                  - "ec2:DeleteTags"
                  - "ec2:CreateTags"
                  - "ec2:DescribeInstanceAttribute"
                  - "ec2:RunInstances"
                  - "ec2:StopInstances"
                  - "elasticloadbalancing:CreateLoadBalancerListeners"
                  - "elasticloadbalancing:DescribeLoadBalancerAttributes"
                  - "elasticloadbalancing:DeleteLoadBalancerPolicy"
                  - "elasticloadbalancing:DescribeLoadBalancers"
                  - "ec2:StartInstances"
                  - "elasticloadbalancing:DescribeLoadBalancerPolicies"
                  - "elasticloadbalancing:DeleteLoadBalancerListeners"
                  - "elasticloadbalancing:CreateLoadBalancerPolicy"
                  - "ec2:DescribeInstanceStatus"
                Resource: "*"
              - Sid: VisualEditor2
                Effect: Allow
                Action:
                  - "logs:DeleteLogGroup"
                  - "logs:CreateLogGroup"
                  - "logs:PutLogEvents"
                  - "elasticloadbalancing:CreateLoadBalancerListeners"
                  - "elasticloadbalancing:DeleteLoadBalancerPolicy"
                  - "elasticloadbalancing:DeleteLoadBalancerListeners"
                  - "elasticloadbalancing:CreateLoadBalancerPolicy"
                  - "sqs:DeleteMessage"
                  - "sqs:GetQueueUrl"
                  - "sqs:ChangeMessageVisibility"
                  - "sqs:SendMessage"
                  - "sqs:ReceiveMessage"
                  - "execute-api:*"
                Resource:
                  - !Sub "arn:aws:sqs:*:${AWS::AccountId}:*"
                  - !Sub "arn:aws:execute-api:*:${AWS::AccountId}:*/*/*/*"
                  - !Sub "arn:aws:elasticloadbalancing:*:${AWS::AccountId}:loadbalancer/*"
                  - !Sub "arn:aws:logs:*:${AWS::AccountId}:log-group:*:log-stream:*"
              - Sid: VisualEditor3
                Effect: Allow
                Action:
                  - "logs:CreateLogStream"
                  - "logs:DeleteLogStream"
                Resource: !Sub "arn:aws:logs:*:${AWS::AccountId}:log-group:*"
              - Sid: VisualEditor4
                Effect: Allow
                Action:
                  - "elasticloadbalancing:DeleteLoadBalancerPolicy"
                  - "elasticloadbalancing:DeleteLoadBalancerListeners"
                  - "elasticloadbalancing:CreateLoadBalancerPolicy"
                  - "elasticloadbalancing:CreateLoadBalancerListeners"
                Resource: !Sub "arn:aws:elasticloadbalancing:*:${AWS::AccountId}:loadbalancer/*"
      RoleName: "LambdaRole"

  ClientConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt LambdaIAMRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          logger = logging.getLogger()
          logger.setLevel("INFO")


          def lambda_handler(event, context):
              print(event)
              connectId = event["requestContext"]["connectionId"]
              # domainName = event["requestContext"]["domainName"]
              # stageName = event["requestContext"]["stage"]
              sourceIp = event["requestContext"]["identity"]["sourceIp"]
              connectionInfo = {
                  'Connection ID': connectId,
                  'Source IP': sourceIp
                  # 'Domain Name': domainName,
                  # 'Stage Name': stageName,
                  # 'Query Strings': qs
              }
              logging.info(connectionInfo)
              return {"statusCode": 200}
      Description: "Print out connection ID when new client connects to websocket"
      FunctionName: "clientConnect"
      Handler: "index.lambda_handler"
      Runtime: "python3.10"
      Timeout: 900

  ClientDisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt LambdaIAMRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import urllib3
          import boto3

          def lambda_handler(event, context):
              # TODO implement
              print(event)
              sqs = boto3.resource('sqs')
              queue = sqs.get_queue_by_name(QueueName='Signalling.fifo')
              connectionId = event["requestContext"]["connectionId"]
              http = urllib3.PoolManager()
              backend_url = os.environ['BACKEND_URL']
              
              data = {
                  'connection_id': connectionId,
                  'status': 'idle'
              }
              encoded_data = json.dumps(data).encode('utf-8')
              resp = http.request(
                  "DELETE", 
                  backend_url,
                  body=encoded_data,
                  headers={'Content-Type': 'application/json'}
              )
              print(resp.status)
              
              messages = queue.receive_messages(MaxNumberOfMessages=10)
              print(messages)
              for message in messages:
                  print(message.body)
                  content = json.loads(message.body)
                  print(content["connection_id"])
                  print(connectionId)
                  print(content["connection_id"] == connectionId)
                  if content.get("connection_id") == connectionId:
                      message.delete()
                      print("deleted")
              return {
                  'statusCode': 200,
                  'body': json.dumps('Hello from Lambda!')
              }
      Description: "Remove connection ID from queue and database when client disconnects from websocket"
      Environment:
        Variables:
          BACKEND_URL: !Ref "BackendURL"
      FunctionName: "clientDisconnect"
      Handler: "index.lambda_handler"
      Runtime: "python3.10"
      Timeout: 900

  ReceiveMessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt LambdaIAMRole.Arn
      Code:
        ZipFile: |
          import os
          import json
          import boto3
          import urllib3

          websocket_client = boto3.client(
              'apigatewaymanagementapi', 
              endpoint_url= os.environ['WEBSOCKET_URL']
          )
          sqs = boto3.resource('sqs')
          queue = sqs.get_queue_by_name(QueueName=os.environ['SQSName'])
          matchmaker_url = os.environ['MATCHMAKER_URL']
          http = urllib3.PoolManager()
          backend_url = os.environ['BACKEND_URL']

          def delete_connection(connectionId):
              data = {
                  'connection_id': connectionId,
                  'status': 'waiting'
              }
              encoded_data = json.dumps(data).encode('utf-8')
              resp = http.request(
                  "POST", 
                  backend_url,
                  body=encoded_data,
                  headers={'Content-Type': 'application/json'}
              )
              print(resp.status)

          def lambda_handler(event, context):
              messageReqId=event["requestContext"]["requestId"]
              uniqueId=str(event["requestContext"]["requestTimeEpoch"])
              connectionId = event["requestContext"]["connectionId"]
              event_body = json.loads(event["body"])
              client_details = {
                      "connection_id": connectionId,
              }
              # When frontend is listening and checking for number of ready servers
              if event_body["job"] == "getNumReadyServers":
                  resp = http.request("GET", matchmaker_url + "/signallingservercount")
                  print(resp.data)
                  response = websocket_client.post_to_connection(
                      ConnectionId=connectionId,
                      Data=json.dumps({
                          "event": "numReadyServers",
                          "count": json.loads(resp.data)["count"]
                      })
                  )
                  # To check with database if userId exist
                  # If userId exists, then replace connection id
                  # else, add new row with connection id
                  data = {
                      'connection_id': connectionId,
                      'status': 'idle'
                  }
                  encoded_data = json.dumps(data).encode('utf-8')
                  resp = http.request(
                      "POST", 
                      backend_url,
                      body=encoded_data,
                      headers={'Content-Type': 'application/json'}
                  )
                  print(resp.data)
                  print("Added " + str(client_details) + " to DB")
                  return {
                      'statusCode': 200,
                  }
              # When frontend is selected to start streaming and waiting for ready server
              # Once ready, frontend will start streaming right away
              elif event_body["job"] == "joinWaitList":
                  # Check with matchmaker server if any signalling servers are ready
                  resp = http.request("GET", matchmaker_url)
                  print("response from matchmaker")
                  print(resp.data)
                  if resp.status != 400:
                      print(resp.data)
                      response = websocket_client.post_to_connection(
                          ConnectionId=connectionId,
                          Data=json.dumps({
                              "event": "signallingServerURL",
                              "ip": json.loads(resp.data)["signallingServer"]
                          })
                      )
                      delete_connection(connectionId)
                      return {
                          'statusCode': 200,
                          'body': "streaming started"
                      }
                  else:
                      delete_connection(connectionId)
                      response = queue.send_message(
                          MessageBody=json.dumps(client_details),
                          MessageGroupId=messageReqId,
                          MessageDeduplicationId=uniqueId
                      )
                      print("Added to queue")
                      # TODO start new instance
                      response = websocket_client.post_to_connection(
                          ConnectionId=connectionId,
                          Data=json.dumps({
                              "event": "wait"
                          })
                      )
                      return {
                          'statusCode': 200,
                          'body': json.dumps(client_details) + " added to queue"
                      }
      Description: "Handle various messages from client and take appropriate action"
      Environment:
        Variables:
          BACKEND_URL: !Ref "BackendURL"
          WEBSOCKET_URL: !Sub "https://${ConnectionHandlerAPI}.execute-api.${AWS::Region}.amazonaws.com/production"
          MATCHMAKER_URL:
            !Join ["", ["http://", !GetAtt MatchMakerServerALB.DNSName, ":90"]]
          SQSName: !GetAtt SessionQueue.QueueName
      FunctionName: "receiveMessage"
      Handler: "index.lambda_handler"
      Runtime: "python3.10"
      Timeout: 900

  CreateInstanceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt LambdaIAMRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          def lambda_handler(event, context):
              
              # this is used to chose a subnet randomly while generating the instance
              allSubnets=['SubnetIdPublicA','SubnetIdPublicB']
              
              matchMakerPrivateIP=''
              ec2MatchMaker = boto3.client('ec2')
              response = ec2MatchMaker.describe_instances(Filters=[{'Name': 'tag:aws:cloudformation:logical-id', 'Values': ['MatchMakingInstance']}])
              
              if(len(response['Reservations'])==1):
                  print(response['Reservations'][0]['Instances'][0]['PrivateIpAddress'])
                  # this is used to retrieve the private ip of Matchmaker which allows Signalling instance to interface with it
                  matchMakerPrivateIP=response['Reservations'][0]['Instances'][0]['PrivateIpAddress']
              
              userData='''#!/bin/bash
              sudo su
              git clone -b UE5.3.3 https://github.com/S35-Capstone-2023/PixelStreamingInfrastructure.git
              aws s3 cp --recursive s3://capstone-storage-s35/Linux ./Linux
              chmod +x ./Linux/Capstone.sh
              ./Linux/Capstone.sh -RenderOffScreen -AudioMixer -PixelStreamingIp=localhost -PixelStreamingPort=8888 & ./PixelStreamingInfrastructure/SignallingWebServer/platform_scripts/Start_WithTURN_SignallingServer.sh --UseMatchmaker true --MatchmakerAddress {}'''.format(matchMakerPrivateIP)
              
              print(event)
              
              ##TODO implement limit for signallingserver
              ec2 = boto3.client('ec2')
              response = ec2.run_instances(
                  ImageId=os.environ["ImageId"],
                  SubnetId=os.environ[allSubnets[0]],
                  LaunchTemplate={'LaunchTemplateName': os.environ["LaunchTemplateName"]},
                  UserData=userData,
                  MinCount=1,
                  MaxCount=1
              )
              print(response['Instances'][0]['InstanceId'])
              # get instance id
              instanceId = response['Instances'][0]['InstanceId']
              
              return {
                  'statusCode': 200,
                  'body': json.dumps('New instance created '+instanceId)
              }
      Description: "Create Signalling instance on a trigger"
      Environment:
        Variables:
          ImageId: !Ref "SignallingServerAMI"
          LaunchTemplateName: "SignallingLaunchTemplate"
          SubnetIdPublicA: !GetAtt PublicSubnet0.SubnetId
          SubnetIdPublicB: !GetAtt PublicSubnet1.SubnetId
      FunctionName: "createInstances"
      Handler: "index.lambda_handler"
      Runtime: "python3.10"
      Timeout: 900

  ClientConnectPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref ClientConnectFunction
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ConnectionHandlerAPI}/*"

  ClientDisconnectPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref ClientDisconnectFunction
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ConnectionHandlerAPI}/*"

  ReceiveMessagePermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref ReceiveMessageFunction
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ConnectionHandlerAPI}/*"

  SessionQueue:
    Type: AWS::SQS::Queue
    Properties:
      DeduplicationScope: "queue"
      FifoQueue: true
      FifoThroughputLimit: "perQueue"
      QueueName: "sessions.fifo"

  ConnectionHandlerAPI:
    Type: "AWS::ApiGatewayV2::Api"
    Properties:
      Name: connectionHandler
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: $request.body.action
      # ApiKeySelectionExpression: $request.header.x-api-key

  OnConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      Description: OnConnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ClientConnectFunction.Arn}/invocations

  OnConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: OnConnectRoute
      RouteResponseSelectionExpression: $default
      Target: !Join
        - "/"
        - - "integrations"
          - !Ref OnConnectIntegration

  OnDisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      Description: OnDisconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ClientDisconnectFunction.Arn}/invocations

  OnDisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: OnDisconnectRoute
      RouteResponseSelectionExpression: $default
      Target: !Join
        - "/"
        - - "integrations"
          - !Ref OnDisconnectIntegration

  ReceiveMessageIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      Description: receiveMessage Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ReceiveMessageFunction.Arn}/invocations

  ReceiveMessageRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ConnectionHandlerAPI
      RouteKey: sendMessage
      AuthorizationType: NONE
      OperationName: ReceiveMessageRoute
      Target: !Join
        - "/"
        - - "integrations"
          - !Ref ReceiveMessageIntegration

  Deployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
      - ReceiveMessageRoute
    Properties:
      ApiId: !Ref ConnectionHandlerAPI

  Stage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      StageName: production
      Description: Prod Stage
      DeploymentId: !Ref Deployment
      ApiId: !Ref ConnectionHandlerAPI

Outputs:
  SignallingServerWSAPI:
    Description: "Web socket endpoint for signalling server"
    Value: !Join ["", ["wss://", !GetAtt SignallingServerALB.DNSName, "?"]]

  APIGatewayAPI:
    Description: "HTTPS endpoint for api server"
    Value: !Sub "wss://${ConnectionHandlerAPI}.execute-api.${AWS::Region}.amazonaws.com/production"
